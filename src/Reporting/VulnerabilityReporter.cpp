#include "Reporting/VulnerabilityReporter.h"
#include <sstream>
#include <map>

VulnerabilityReporter::VulnerabilityReporter(
    const std::vector<Vulnerability>& vulnerabilities,
    const std::string& outputFormat
) : vulnerabilities(vulnerabilities), outputFormat(outputFormat) {}

std::string VulnerabilityReporter::generateTextReport() const {
    if (vulnerabilities.empty()) {
        return "No vulnerabilities detected.";
    }

    std::ostringstream report;
    report << "=== VULNERABILITY REPORT ===\n\n";

    // Group vulnerabilities by file
    std::map<std::string, std::vector<Vulnerability>> vulnerabilitiesByFile;
    for (const auto& vuln : vulnerabilities) {
        vulnerabilitiesByFile[vuln.filePath].push_back(vuln);
    }

    // Generate report for each file
    for (const auto& [filePath, vulns] : vulnerabilitiesByFile) {
        report << "FILE: " << filePath << "\n";
        report << std::string(40, '-') << "\n\n";

        for (size_t i = 0; i < vulns.size(); ++i) {
            const auto& vuln = vulns[i];
            report << "[" << (i + 1) << "] " << to_string(vuln.severity) << " - " 
                   << to_string(vuln.type) << "\n";
            report << "    Line " << vuln.lineNumber << ", Column " << vuln.column << "\n";
            report << "    " << vuln.description << "\n\n";
            report << "    Code: " << vuln.codeSnippet << "\n\n";

            if (!vuln.possibleFix.empty()) {
                report << "    Suggested Fix: " << vuln.possibleFix << "\n\n";
            }

            report << "\n";
        }
    }

    // Summary section
    std::map<SeverityLevel, int> severityCounts;
    for (const auto& vuln : vulnerabilities) {
        severityCounts[vuln.severity]++;
    }

    report << "=== SUMMARY ===\n";
    report << "Total vulnerabilities: " << vulnerabilities.size() << "\n";
    
    // Print counts for each severity level
    for (int level = static_cast<int>(SeverityLevel::LOW); 
         level <= static_cast<int>(SeverityLevel::CRITICAL); 
         level++) {
        
        auto severityLevel = static_cast<SeverityLevel>(level);
        report << to_string(severityLevel) << ": " 
               << severityCounts[severityLevel] << "\n";
    }

    return report.str();
}

std::string VulnerabilityReporter::generateJsonReport() const {
    // A simplified JSON generator
    std::ostringstream json;
    json << "{\n";
    json << "  \"total_vulnerabilities\": " << vulnerabilities.size() << ",\n";
    json << "  \"vulnerabilities\": [\n";

    for (size_t i = 0; i < vulnerabilities.size(); ++i) {
        const auto& vuln = vulnerabilities[i];
        json << "    {\n";
        json << "      \"type\": \"" << to_string(vuln.type) << "\",\n";
        json << "      \"severity\": \"" << to_string(vuln.severity) << "\",\n";
        json << "      \"file\": \"" << vuln.filePath << "\",\n";
        json << "      \"line\": " << vuln.lineNumber << ",\n";
        json << "      \"column\": " << vuln.column << ",\n";
        json << "      \"description\": \"" << vuln.description << "\",\n";
        json << "      \"code\": \"" << escapeJsonString(vuln.codeSnippet) << "\",\n";
        json << "      \"fix\": \"" << escapeJsonString(vuln.possibleFix) << "\"\n";
        json << "    }";
        
        if (i < vulnerabilities.size() - 1) {
            json << ",";
        }
        
        json << "\n";
    }

    json << "  ]\n";
    json << "}\n";

    return json.str();
}

std::string VulnerabilityReporter::escapeJsonString(const std::string& input) const {
    std::string result;
    for (char c : input) {
        switch (c) {
            case '\"': result += "\\\""; break;
            case '\\': result += "\\\\"; break;
            case '\b': result += "\\b"; break;
            case '\f': result += "\\f"; break;
            case '\n': result += "\\n"; break;
            case '\r': result += "\\r"; break;
            case '\t': result += "\\t"; break;
            default:
                if (c < 32) {
                    // For control characters, use \uXXXX notation
                    char buffer[7];
                    snprintf(buffer, sizeof(buffer), "\\u%04x", c);
                    result += buffer;
                } else {
                    result += c;
                }
        }
    }
    return result;
}

std::string VulnerabilityReporter::generateReport() const {
    if (outputFormat == "text") {
        return generateTextReport();
    } else if (outputFormat == "json") {
        return generateJsonReport();
    } else {
        return "Unsupported output format: " + outputFormat;
    }
}